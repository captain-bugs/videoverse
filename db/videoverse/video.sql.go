// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: video.sql

package videoversedb

import (
	"context"
	"database/sql"
	"time"
)

const deleteVideoByID = `-- name: DeleteVideoByID :exec
DELETE
FROM videos
WHERE id = ?
`

func (q *Queries) DeleteVideoByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteVideoByID, id)
	return err
}

const getLinksSharedByUserID = `-- name: GetLinksSharedByUserID :many
SELECT id, video_id, user_id, link, expires_at, created_at
FROM shared_links
WHERE user_id = ?
`

func (q *Queries) GetLinksSharedByUserID(ctx context.Context, userID int64) ([]SharedLink, error) {
	rows, err := q.db.QueryContext(ctx, getLinksSharedByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SharedLink
	for rows.Next() {
		var i SharedLink
		if err := rows.Scan(
			&i.ID,
			&i.VideoID,
			&i.UserID,
			&i.Link,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email, password_hash, created_at
FROM users
WHERE id = ?
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const getVideoByID = `-- name: GetVideoByID :one
SELECT id, title, description, user_id, source_video_id, type, file_path, file_name, size_in_bytes, duration, start_time, end_time, metadata, created_at, updated_at
FROM videos
WHERE id = ?
`

func (q *Queries) GetVideoByID(ctx context.Context, id int64) (Video, error) {
	row := q.db.QueryRowContext(ctx, getVideoByID, id)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.UserID,
		&i.SourceVideoID,
		&i.Type,
		&i.FilePath,
		&i.FileName,
		&i.SizeInBytes,
		&i.Duration,
		&i.StartTime,
		&i.EndTime,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVideosByUserID = `-- name: GetVideosByUserID :many
SELECT id, title, description, user_id, source_video_id, type, file_path, file_name, size_in_bytes, duration, start_time, end_time, metadata, created_at, updated_at
FROM videos
WHERE user_id = ?
`

func (q *Queries) GetVideosByUserID(ctx context.Context, userID int64) ([]Video, error) {
	rows, err := q.db.QueryContext(ctx, getVideosByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Video
	for rows.Next() {
		var i Video
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.UserID,
			&i.SourceVideoID,
			&i.Type,
			&i.FilePath,
			&i.FileName,
			&i.SizeInBytes,
			&i.Duration,
			&i.StartTime,
			&i.EndTime,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveSharedLink = `-- name: SaveSharedLink :one
INSERT INTO shared_links (user_id, video_id, link, expires_at, created_at)
VALUES (?, ?, ?, ?, ?)
RETURNING id, video_id, user_id, link, expires_at, created_at
`

type SaveSharedLinkParams struct {
	UserID    int64
	VideoID   int64
	Link      string
	ExpiresAt time.Time
	CreatedAt sql.NullTime
}

func (q *Queries) SaveSharedLink(ctx context.Context, arg SaveSharedLinkParams) (SharedLink, error) {
	row := q.db.QueryRowContext(ctx, saveSharedLink,
		arg.UserID,
		arg.VideoID,
		arg.Link,
		arg.ExpiresAt,
		arg.CreatedAt,
	)
	var i SharedLink
	err := row.Scan(
		&i.ID,
		&i.VideoID,
		&i.UserID,
		&i.Link,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const saveUser = `-- name: SaveUser :one
INSERT INTO users (email, username, password_hash, created_at)
VALUES (?, ?, ?, ?)
RETURNING id, username, email, password_hash, created_at
`

type SaveUserParams struct {
	Email        string
	Username     string
	PasswordHash string
	CreatedAt    sql.NullTime
}

func (q *Queries) SaveUser(ctx context.Context, arg SaveUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, saveUser,
		arg.Email,
		arg.Username,
		arg.PasswordHash,
		arg.CreatedAt,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const saveVideo = `-- name: SaveVideo :one
INSERT INTO videos (user_id,
                    title,
                    description,
                    type,
                    file_path,
                    file_name,
                    size_in_bytes,
                    duration,
                    metadata,
                    start_time,
                    end_time,
                    source_video_id,
                    created_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, title, description, user_id, source_video_id, type, file_path, file_name, size_in_bytes, duration, start_time, end_time, metadata, created_at, updated_at
`

type SaveVideoParams struct {
	UserID        int64
	Title         string
	Description   string
	Type          string
	FilePath      string
	FileName      string
	SizeInBytes   int64
	Duration      float64
	Metadata      sql.NullString
	StartTime     sql.NullFloat64
	EndTime       sql.NullFloat64
	SourceVideoID sql.NullInt64
	CreatedAt     sql.NullTime
}

func (q *Queries) SaveVideo(ctx context.Context, arg SaveVideoParams) (Video, error) {
	row := q.db.QueryRowContext(ctx, saveVideo,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.Type,
		arg.FilePath,
		arg.FileName,
		arg.SizeInBytes,
		arg.Duration,
		arg.Metadata,
		arg.StartTime,
		arg.EndTime,
		arg.SourceVideoID,
		arg.CreatedAt,
	)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.UserID,
		&i.SourceVideoID,
		&i.Type,
		&i.FilePath,
		&i.FileName,
		&i.SizeInBytes,
		&i.Duration,
		&i.StartTime,
		&i.EndTime,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
